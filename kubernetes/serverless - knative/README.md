# [Knative - Serverless 应用的构建、部署与管理平台](https://github.com/knative)

## Serverless 介绍

Serverless 指对平台的用户屏蔽掉了服务器层面的配置和管理， Serverless 平台自己把这些“脏活累活”都默默干好了。上层用户（后端开发）只需要关注自己的业务逻辑，而运维就可以下岗了。。。

Serverless 的好处是它**分离了关注点**，底层的服务器配置与管理被直接封装好了。用户需要关注的东西少了，效率也就更高了。

目前的 Serverless 产品有好几种，它们分别实现了不同级别的 Serverless 能力：

1. 阿里云 Serverless Kubernetes: 提供了一套与节点(Node)无关的 k8s 系统，运维人员不再需要考虑服务器的扩缩容问题。
    - 这是比较靠近底层的 Serverless 产品，因为 k8s 本身还比较底层，容器的调度、灰度升级回滚、扩缩容等还是需要运维通过 k8s 来处理。
1. 基于容器的 Serverless 平台（Knatvie）：用户只需要提供容器，Knative 自己帮你把容器调度、灰度升级回滚、弹性扩缩容等都干了。
    - 这个是容器级别的 Serverless，比 Serverless  K8s 更进一步地分离了关注点。
    - 比较适合基于微服务架构的应用。
2. 函数计算（Function as a Server, FaaS）：将运维能力封装到了极致。用户只要给源码，其他的杂事都由云平台处理。
    - 目前还处于比较早期的阶段，落地案例比较少。
    - 函数式计算按 API 调用次数以及资源使用量收费，而且有很高的免费额度。很值得自己尝试一下。

另外，上述所有的容器、函数，都必须是无状态的（Stateless），因为显然只有无状态的容器/函数，才可以随意的扩缩容。

目前我并没发现哪家云厂商提供了使用 Serverless 部署有状态应用/容器的功能。
相反我只看到云厂商们说：应用自己应该是无状态的，所有数据都应该用我们的对象存储(OSS)、数据库等产品来保存。

## 架构

Knative 由两大组件组成：

1. Servering（工作负载管理）: 负责处理容器部署、网络、扩缩容和版本追踪。
2. Eventing（事件管理）: 统一的事件管理，

Knative 本身只提供容器级别的 Serverless 能力，而从源码到容器的流程，它建议你使用 Tekton:

1. [Tekton](/CI-CD/tekton/README.md): 一个云原生的 CI/CD 流水线。


结合上述三个组件，就得到了 Knative: 应用从源码到生产环境的全生命周期管理平台。

此外，Knative 还可以与服务网格 Istio 结合，提供服务路由管理、灰度发布等功能。


## 应用场景

Knative 感觉还是太底层了，抽象程度更好，对运维而言复杂度又增加了。
而且为了实现「缩容到 0」、「按并发请求数进行扩容」等操作，Knative 增加了一个网络代理（流量又多转发一次、甚至可能还要等待应用扩容到 1）。

而「缩容至0」对微服务架构而言意义不大，首先就不确定微服务流量会不会低到几乎没有，其次扩缩容对微服务而言速度还是比较慢的（好几秒）。
就为了这么个特性而增加网络性能损耗，甚至还可能会让用户等待微服务扩容，个人感觉是得不偿失。

Knative 应该是比较适合比微服务更轻量的 FaaS 架构。
在 FaaS 架构下，业务被拆分得更细了，更轻量级的容器显然能获得更快的扩缩容速度，这时从 0 扩容到 1 的等待过程，对用户而言可能就可以接受了。
另外对数量庞大的 Fucntions 而言，将大量「非热点 Functions」缩容到 0 也许能节约大量资源。
「缩容到 0」对 FaaS 意义很大。

## 参考


- [《Knative 云原生应用开发指南》开启云原生时代 Serverless 之门 - 阿里云社区](https://developer.aliyun.com/article/739122)
- [实现Serverless面临的五大挑战](https://zhuanlan.zhihu.com/p/143389610)
